/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.unrealscriptsupport.options.global;

import java.awt.Color;
import java.util.*;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import org.openide.util.Exceptions;
import org.openide.util.NbPreferences;

public final class UnrealScriptToolsPanel extends javax.swing.JPanel {

    public static final String NEW_ITEM_NAME = "New Collection";
    public static final String DELIM = "\\.";
    public static final String UNKNOWN_STRING = "<unknown>";
    public static final String DUPLICATE_DELIM = " ";

    public static final boolean DEBUG = true;

    private final UnrealScriptToolsOptionsPanelController controller;

    private List<ToolCollectionData> prefsList = new LinkedList<ToolCollectionData>();
    
    private List<String> namesList = new LinkedList<String>();
    private int selectionIndex = -1;
    private ToolCollectionData selection = null;

    public UnrealScriptToolsPanel(UnrealScriptToolsOptionsPanelController controller) {
        this.controller = controller;
        initComponents();
        // TODO listen to changes in form fields and call controller.changed()
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        collectionList = new javax.swing.JList();
        addButton = new javax.swing.JButton();
        duplicateButton = new javax.swing.JButton();
        removeButton = new javax.swing.JButton();
        defaultButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        collectionNameTextField = new javax.swing.JTextField();
        jPanel3 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        compilerBasedirTextField = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        compilerFileNameTextField = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        compilerArgsTextField = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        compilerResultDirTextField = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        executablePathTextField = new javax.swing.JTextField();
        nameErrorLabel = new javax.swing.JLabel();
        nameErrorLabel.setVisible(false);

        collectionList.setModel(new javax.swing.AbstractListModel() {
            String[] strings = { "Item 1", "Item 2" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        collectionList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        collectionList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                collectionListValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(collectionList);
        collectionList.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.collectionList.AccessibleContext.accessibleName")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(addButton, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.addButton.text")); // NOI18N
        addButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(duplicateButton, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.duplicateButton.text")); // NOI18N
        duplicateButton.setEnabled(false);
        duplicateButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                duplicateButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(removeButton, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.removeButton.text")); // NOI18N
        removeButton.setEnabled(false);
        removeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(defaultButton, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.defaultButton.text")); // NOI18N
        defaultButton.setEnabled(false);

        jLabel1.setLabelFor(collectionList);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel1.text")); // NOI18N

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 186, Short.MAX_VALUE)
                    .addComponent(jLabel1)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(removeButton, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE)
                            .addComponent(addButton, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(defaultButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(duplicateButton, javax.swing.GroupLayout.DEFAULT_SIZE, 89, Short.MAX_VALUE))))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(addButton)
                    .addComponent(duplicateButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(removeButton)
                    .addComponent(defaultButton))
                .addContainerGap())
        );

        jLabel1.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel1.AccessibleContext.accessibleName")); // NOI18N

        jSplitPane1.setLeftComponent(jPanel1);

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel2.text")); // NOI18N

        collectionNameTextField.setText(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.collectionNameTextField.text")); // NOI18N
        collectionNameTextField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                collectionNameTextFieldKeyTyped(evt);
            }
        });

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jPanel3.border.title"))); // NOI18N

        jLabel3.setLabelFor(compilerBasedirTextField);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel3.text")); // NOI18N

        compilerBasedirTextField.setText(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.compilerBasedirTextField.text")); // NOI18N

        jLabel4.setLabelFor(compilerFileNameTextField);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel4.text")); // NOI18N

        compilerFileNameTextField.setText(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.compilerFileNameTextField.text")); // NOI18N

        jLabel5.setLabelFor(compilerArgsTextField);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel5.text")); // NOI18N

        compilerArgsTextField.setText(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.compilerArgsTextField.text")); // NOI18N

        jLabel6.setLabelFor(compilerResultDirTextField);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel6, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel6.text")); // NOI18N

        compilerResultDirTextField.setText(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.compilerResultDirTextField.text")); // NOI18N

        jLabel7.setLabelFor(executablePathTextField);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel7, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel7.text")); // NOI18N

        executablePathTextField.setText(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.executablePathTextField.text")); // NOI18N

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel5)
                    .addComponent(jLabel4)
                    .addComponent(jLabel6)
                    .addComponent(jLabel3)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(executablePathTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
                    .addComponent(compilerBasedirTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
                    .addComponent(compilerResultDirTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
                    .addComponent(compilerFileNameTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
                    .addComponent(compilerArgsTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(compilerBasedirTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(compilerFileNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(compilerArgsTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(compilerResultDirTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel7)
                    .addComponent(executablePathTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        nameErrorLabel.setForeground(new java.awt.Color(255, 0, 0));
        nameErrorLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/unrealscriptsupport/resources/error.png"))); // NOI18N
        nameErrorLabel.setLabelFor(collectionNameTextField);
        org.openide.awt.Mnemonics.setLocalizedText(nameErrorLabel, org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.nameErrorLabel.text")); // NOI18N

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(nameErrorLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 280, Short.MAX_VALUE)
                            .addComponent(collectionNameTextField, javax.swing.GroupLayout.DEFAULT_SIZE, 280, Short.MAX_VALUE)))
                    .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(collectionNameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(nameErrorLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jLabel2.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.jLabel2.AccessibleContext.accessibleName")); // NOI18N
        collectionNameTextField.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.collectionNameTextField.AccessibleContext.accessibleName")); // NOI18N
        nameErrorLabel.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(UnrealScriptToolsPanel.class, "UnrealScriptToolsPanel.nameErrorLabel.AccessibleContext.accessibleName")); // NOI18N

        jSplitPane1.setRightComponent(jPanel2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 592, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * User has picked a new collection from the list, load preferences.
     * @param evt
     */
    private void collectionListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_collectionListValueChanged

        updateSelection();
        return;
    }//GEN-LAST:event_collectionListValueChanged

    /**
     * Update name in collectionList when name in the text field is changed.
     * @param evt
     */
    private void collectionNameTextFieldKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_collectionNameTextFieldKeyTyped

        editName();
        return;
    }//GEN-LAST:event_collectionNameTextFieldKeyTyped

    private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addButtonActionPerformed

        addItem(new ToolCollectionData(NEW_ITEM_NAME));
        return;
    }//GEN-LAST:event_addButtonActionPerformed


    private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeButtonActionPerformed

        removeItem();
        return;
    }//GEN-LAST:event_removeButtonActionPerformed


    private void duplicateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_duplicateButtonActionPerformed

        duplicateItem();
        return;
    }//GEN-LAST:event_duplicateButtonActionPerformed

    private void addItem(ToolCollectionData item) {

        // -- Add an item to the list
        // - Check name is not duplicated
        int duplicated = 1;
        String newName = item.name + DUPLICATE_DELIM + duplicated;

        Iterator<String> itr = namesList.iterator();
        while (itr.hasNext()) {
            String value = itr.next();

            if (newName.equalsIgnoreCase(value)) {
                ++duplicated;
                newName = item.name + DUPLICATE_DELIM + duplicated;
            }
        }

        // Set name with number on the end
        item.name = newName;

        // - Add new item to preferences
        prefsList.add(item);

        // - Add to end of namesList
        namesList.add(item.name);

        // - Add namesList to collectionList
        collectionList.setListData(namesList.toArray());

        // Nothing was selected, but new item added
        //if (selectionIndex < 0) {
        //    selectionIndex = 0;
        //}
        // Select new item
        selectionIndex = namesList.indexOf(item.name);
        // Preserve selection
        select(selectionIndex);

        // -- Mark as changed
        controller.changed();

        return;
    }
    
    private void removeItem() {

        // -- Nothing selected
        if (selectionIndex < 0) {
            return;
        }

        // -- Remove
        // - Remove from preferences
        prefsList.remove(selectionIndex);

        // - Add to end of namesList
        namesList.remove(selectionIndex);

        // - Add namesList to collectionList
        collectionList.setListData(namesList.toArray());

        // -- Decrement selection
        --selectionIndex;

        // Deleted 1st element, but still items left in list
        if ( (selectionIndex < 0) && (namesList.size() > 0) ) {
            // Select 1st item
            selectionIndex = 0;
        }

        // - Set selection
        if (selectionIndex >= 0) {
            select(selectionIndex);
        }
        else {
            deselect();
        }

        // -- Mark as changed
        controller.changed();

        return;
    }

    private void duplicateItem() {

        // -- Nothing selected
        if (selectionIndex < 0) {
            return;
        }

        // -- Duplicate value in list box
        addItem(new ToolCollectionData(prefsList.get(selectionIndex)));

        // -- Mark as changed
        // Already done in addItem
        //controller.changed();

        return;
    }

    /**
     * Validate the name while the user types it in.
     */
    private void editName() {

        // -- Nothing is selected
        if (selection == null) {
            return;
        }

        String newName = collectionNameTextField.getText();

        // -- Edit selection
        // - Don't edit if name is duplicated
        // Copy namesList
        List<String> editList = new LinkedList(namesList);
        // Remove current selection from list
        editList.remove(selectionIndex);
        // If the list still contains the name, there is a duplicate
        if (editList.contains(newName)) {

            // Don't change name data
            // But still update in list
            //namesList.set(selectionIndex, newName);

            // Flag with error
            nameErrorLabel.setVisible(true);
            collectionNameTextField.setForeground(Color.red);
        }
        else {
            // Change name data
            //selection.name = newName;

            // Update namesList
            //namesList.set(selectionIndex, selection.name);

            // Update collectionList with nameslist
            // Don't reload preferences
            //collectionList.setListData(namesList.toArray());
            //collectionList.setSelectedIndex(selectionIndex);

            // Remove error flag
            nameErrorLabel.setVisible(false);
            collectionNameTextField.setForeground(Color.black);
        }

        return;
    }

    /**
     * An item in collectionList has been selected or deselected.
     */
    private void updateSelection() {
        
        // -- Get selected value in list box
        // Updates selectionIndex and namesList
        // so don't use them here
        if (!collectionList.isSelectionEmpty()) {
            select(collectionList.getSelectedValue().toString());
        }
        else {
            deselect();
        }
        
        return;
    }

    /**
     * An item in collectionList has been selected.
     * Update selection data and GUI.
     * @param value name of selected item.
     */
    private void select(String value) {
        selectionIndex = namesList.indexOf(value);
        select(selectionIndex);
        return;
    }

    /**
     * An item in collectionList has been selected.
     * Update selection data and GUI.
     * @param index index of selected item.
     */
    private void select(int index) {

        // Selection data
        selectionIndex = index;
        selection = prefsList.get(index);

        // List
        collectionList.setSelectedIndex(selectionIndex);

        // List buttons
        removeButton.setEnabled(true);
        duplicateButton.setEnabled(true);
        defaultButton.setEnabled(false);

        // Load preferences
        loadTools(selectionIndex);

        return;
    }

    /**
     * Items in collectionList have been de-selected.
     */
    private void deselect() {

        // Selection data
        selectionIndex = -1;
        selection = null;

        // List
        collectionList.clearSelection();

        // List buttons
        removeButton.setEnabled(false);
        duplicateButton.setEnabled(false);
        defaultButton.setEnabled(false);

        // Leave as blank, nothing selected
        clearTools();

        return;
    }

    /**
     * Copy text from text boxes into "selection".
     */
    private void copyTextToSelection() {

        if (selection == null) {
            return;
        }

        selection.name = collectionNameTextField.getText();
        selection.compilerArgs = compilerArgsTextField.getText();
        selection.compilerBaseDir = compilerBasedirTextField.getText();
        selection.compilerFileName = compilerFileNameTextField.getText();
        selection.compilerResultDir = compilerResultDirTextField.getText();
        selection.executableFileName = executablePathTextField.getText();
        return;
    }

    /**
     * Read settings and initialize GUI.
     * Example:
     * someCheckBox.setSelected(Preferences
     * .userNodeForPackage(UnrealScriptToolsPanel.class).getBoolean("someFlag", false));
     * or for org.openide.util with API spec. version >= 7.4:
     * someCheckBox.setSelected(NbPreferences
     * .forModule(UnrealScriptToolsPanel.class).getBoolean("someFlag", false));
     * or:
     * someTextField.setText(SomeSystemOption.getDefault().getSomeStringProperty());
     */
    public void load() {
        loadPreferences();
        return;
    }

    /**
     * Store modified settings.
     * Example:
     * Preferences.userNodeForPackage(UnrealScriptToolsPanel.class)
     * .putBoolean("someFlag", someCheckBox.isSelected());
     * or for org.openide.util with API spec. version >= 7.4:
     * NbPreferences.forModule(UnrealScriptToolsPanel.class)
     * .putBoolean("someFlag", someCheckBox.isSelected());
     * or:
     * SomeSystemOption.getDefault().setSomeStringProperty(someTextField.getText());
     */
    void store() {
        writePreferences();
        return;
    }

    boolean valid() {
        // TODO check whether form is consistent and complete
        return true;
    }

    /**
     * Load preferences from file into prefsList.
     */
    void loadPreferences() {

        final Preferences prefs = NbPreferences.forModule(UnrealScriptToolsPanel.class);

        try {
            final String[] prefsNames = prefs.keys();

            for (int i = 0; i < prefsNames.length; ++i) {

                // Read property
                // eg. KillingFloor.compiler.args=make
                String name = prefsNames[i];
                String[] propsNames = name.split(DELIM);
                if (propsNames.length < 3) {
                    if (DEBUG) {
                        throw new RuntimeException("Invalid property: " + name);
                    }
                    else {
                        continue;
                    }
                }

                ToolCollectionData tc = new ToolCollectionData(propsNames[0]);

                // Add new collection
                // eg. KillingFloor.name=Killing Floor
                // where "KillingFloor" has not been added to prefsList
                if (!prefsList.contains(tc)) {
                    prefsList.add(tc);
                }
                // Collection already partially read in
                // Get existing collection
                // eg. KillingFloor.name=Killing Floor
                // was already added to prefsList
                else {
                    tc = prefsList.get(prefsList.indexOf(tc));
                }

                // eg. KillingFloor.compiler.args=make
                if(ToolCollectionData.COMPILER_STRING.equals(propsNames[1])) {

                    if(ToolCollectionData.ARGS_STRING.equals(propsNames[2])) {
                        tc.compilerArgs = prefs.get(name, UNKNOWN_STRING);
                    }
                    else if(ToolCollectionData.BASE_DIR_STRING.equals(propsNames[2])) {
                        tc.compilerBaseDir = prefs.get(name, UNKNOWN_STRING);
                    }
                    else if(ToolCollectionData.FILE_NAME_STRING.equals(propsNames[2])) {
                        tc.compilerFileName = prefs.get(name, UNKNOWN_STRING);
                    }
                    else if(ToolCollectionData.RESULT_DIR_STRING.equals(propsNames[2])) {
                        tc.compilerResultDir = prefs.get(name, UNKNOWN_STRING);
                    }
                }

                // eg. KillingFloor.executable.filename=kf.exe
                else if(ToolCollectionData.EXECUTABLE_STRING.equals(propsNames[1])) {

                    if(ToolCollectionData.FILE_NAME_STRING.equals(propsNames[2])) {
                        tc.executableFileName = prefs.get(name, UNKNOWN_STRING);
                    }
                }
                else {
                    if (DEBUG) {
                        throw new RuntimeException("Unknown preference: " + name);
                    }
                    else {
                        continue;
                    }
                }
            }
        }
        catch (BackingStoreException ex) {
            if (DEBUG) {
                Exceptions.printStackTrace(ex);
            }
        }

        // Add prefs to namesList and collectionList
        updateNamesList();

        // Clear selection
        deselect();

        return;
    }

    void writePreferences() {
        final Preferences prefs = NbPreferences.forModule(UnrealScriptToolsPanel.class);

        try {
            prefs.clear();

            Iterator<ToolCollectionData> itr = prefsList.iterator();

            while (itr.hasNext()) {
                ToolCollectionData tc = itr.next();

                StringBuilder sb;

                sb = new StringBuilder();
                sb.append(tc.name);
                sb.append(".");
                sb.append(ToolCollectionData.COMPILER_STRING);
                sb.append(".");
                sb.append(ToolCollectionData.ARGS_STRING);
                prefs.put(sb.toString(), tc.compilerArgs);

                sb = new StringBuilder();
                sb.append(tc.name);
                sb.append(".");
                sb.append(ToolCollectionData.COMPILER_STRING);
                sb.append(".");
                sb.append(ToolCollectionData.BASE_DIR_STRING);
                prefs.put(sb.toString(), tc.compilerBaseDir);

                sb = new StringBuilder();
                sb.append(tc.name);
                sb.append(".");
                sb.append(ToolCollectionData.COMPILER_STRING);
                sb.append(".");
                sb.append(ToolCollectionData.FILE_NAME_STRING);
                prefs.put(sb.toString(), tc.compilerFileName);

                sb = new StringBuilder();
                sb.append(tc.name);
                sb.append(".");
                sb.append(ToolCollectionData.COMPILER_STRING);
                sb.append(".");
                sb.append(ToolCollectionData.RESULT_DIR_STRING);
                prefs.put(sb.toString(), tc.compilerResultDir);

                sb = new StringBuilder();
                sb.append(tc.name);
                sb.append(".");
                sb.append(ToolCollectionData.EXECUTABLE_STRING);
                sb.append(".");
                sb.append(ToolCollectionData.FILE_NAME_STRING);
                prefs.put(sb.toString(), tc.executableFileName);
            }

        } catch (BackingStoreException ex) {
            Exceptions.printStackTrace(ex);
        }

        return;
    }

    private void updateNamesList() {

        // Update namesList
        namesList.clear();

        Iterator<ToolCollectionData> itr = prefsList.iterator();

        while (itr.hasNext()) {
            ToolCollectionData tc = itr.next();
            namesList.add(tc.name);
        }

        // Update collectionList with namesList
        refreshCollectionList();

        return;
    }

    private void refreshCollectionList() {
        collectionList.setListData(namesList.toArray());
        if (selectionIndex > 0) {
            select(selectionIndex);
        }
        return;
    }

    private void loadTools(int index) {

        ToolCollectionData tc = prefsList.get(index);

        collectionNameTextField.setText(tc.name);
        collectionNameTextField.setEnabled(true);

        compilerBasedirTextField.setText(tc.compilerBaseDir);
        compilerBasedirTextField.setEnabled(true);

        compilerFileNameTextField.setText(tc.compilerFileName);
        compilerFileNameTextField.setEnabled(true);

        compilerArgsTextField.setText(tc.compilerArgs);
        compilerArgsTextField.setEnabled(true);

        compilerResultDirTextField.setText(tc.compilerResultDir);
        compilerResultDirTextField.setEnabled(true);

        executablePathTextField.setText(tc.executableFileName);
        executablePathTextField.setEnabled(true);

        return;
    }

    private void clearTools() {

        collectionNameTextField.setText("");
        collectionNameTextField.setEnabled(false);

        compilerBasedirTextField.setText("");
        compilerBasedirTextField.setEnabled(false);

        compilerFileNameTextField.setText("");
        compilerFileNameTextField.setEnabled(false);

        compilerArgsTextField.setText("");
        compilerArgsTextField.setEnabled(false);

        compilerResultDirTextField.setText("");
        compilerResultDirTextField.setEnabled(false);

        executablePathTextField.setText("");
        executablePathTextField.setEnabled(false);

        return;
    }

    /**
     * Class for storing tool collection preferences.
     * eg.
     * KillingFloor.name=Killing Floor
     * KillingFloor.compiler.args=make1
     * KillingFloor.compiler.basedir=base1
     * KillingFloor.compiler.filename=ucc1
     * KillingFloor.compiler.resultdir=system1
     * KillingFloor.executable.filename=kf.exe
     */
    private class ToolCollectionData {

        public static final String COMPILER_STRING = "compiler";
        public static final String EXECUTABLE_STRING = "executable";

        public static final String ARGS_STRING = "args";
        public static final String BASE_DIR_STRING = "basedir";
        public static final String FILE_NAME_STRING = "filename";
        public static final String RESULT_DIR_STRING = "resultdir";

        public String name = UNKNOWN_STRING;
        public String compilerArgs = UNKNOWN_STRING;
        public String compilerBaseDir = UNKNOWN_STRING;
        public String compilerFileName = UNKNOWN_STRING;
        public String compilerResultDir = UNKNOWN_STRING;
        public String executableFileName = UNKNOWN_STRING;

        public ToolCollectionData(String name) {
            this.name = name;
        }

        public ToolCollectionData(ToolCollectionData other) {
            set(other);
        }

        private void set(ToolCollectionData other) {
            this.name = other.name;
            this.compilerArgs = other.compilerArgs;
            this.compilerBaseDir = other.compilerBaseDir;
            this.compilerFileName = other.compilerFileName;
            this.compilerResultDir = other.compilerResultDir;
            this.executableFileName = other.executableFileName;
            return;
        }

        @Override
        public boolean equals(Object other) {

            if (other == null) {
                return false;
            }
            else if(other == this) {
                return true;
            }

            else if(other instanceof ToolCollectionData) {
                ToolCollectionData o = (ToolCollectionData) other;

                if ( (this.name == null) &&
                     (o.name == null) ) {
                    return true;
                }
                else if(this.name.equals(o.name)) {
                    return true;
                }
            }

            return false;
        }

        @Override
        public int hashCode() {
            int hash = 3;
            hash = 47 * hash + (this.name != null ? this.name.hashCode() : 0);
            return hash;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            sb.append(name);
            sb.append("\n");

            sb.append(COMPILER_STRING);
            sb.append(".");
            sb.append(ARGS_STRING);
            sb.append(" = ");
            sb.append(compilerArgs);
            sb.append("\n");

            sb.append(COMPILER_STRING);
            sb.append(".");
            sb.append(BASE_DIR_STRING);
            sb.append(" = ");
            sb.append(compilerBaseDir);
            sb.append("\n");

            sb.append(COMPILER_STRING);
            sb.append(".");
            sb.append(FILE_NAME_STRING);
            sb.append(" = ");
            sb.append(compilerFileName);
            sb.append("\n");

            sb.append(COMPILER_STRING);
            sb.append(".");
            sb.append(RESULT_DIR_STRING);
            sb.append(" = ");
            sb.append(compilerResultDir);
            sb.append("\n");

            sb.append(EXECUTABLE_STRING);
            sb.append(".");
            sb.append(FILE_NAME_STRING);
            sb.append(" = ");
            sb.append(executableFileName);
            sb.append("\n");

            return sb.toString();
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addButton;
    private javax.swing.JList collectionList;
    private javax.swing.JTextField collectionNameTextField;
    private javax.swing.JTextField compilerArgsTextField;
    private javax.swing.JTextField compilerBasedirTextField;
    private javax.swing.JTextField compilerFileNameTextField;
    private javax.swing.JTextField compilerResultDirTextField;
    private javax.swing.JButton defaultButton;
    private javax.swing.JButton duplicateButton;
    private javax.swing.JTextField executablePathTextField;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JLabel nameErrorLabel;
    private javax.swing.JButton removeButton;
    // End of variables declaration//GEN-END:variables
}
